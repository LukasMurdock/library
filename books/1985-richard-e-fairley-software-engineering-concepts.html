<dl vocab="https://schema.org/" typeof="Book">
<dt>Name</dt>
<dd property="name">Software Engineering Concepts</dd>
<dt>Author</dt>
<dd property="author">Richard E. Fairley</dd>
<dt>Pages</dt>
<dd property="numberOfPages">392</dd>
<dt>Date Published</dt>
<dd property="datePublished">1985</dd>
<dt>Bookshelves</dt>
<dd property="bookshelf">Have Read</dd>
<dt>Genres</dt>
<dd property="genre">Computers</dd>
</dl>
<details>
    <summary>Table of contents</summary>
    <ol>
        <li>
            Introduction to Software Engineering
            <ol>
                <li>Introduction</li>
                <li>Some Definitions</li>
                <li>Some Size Factors</li>
                <li>Quality and Productivity Factors</li>
                <li>Managerial Issues</li>
            </ol>
        </li>
        <li>
            Planning a Software Project
            <ol>
                <li>Introduction</li>
                <li>
                    Defining the Problem
                    <ol>
                        <li>Goals and Requirements</li>
                    </ol>
                </li>
                <li>Developing a Solution Strategy</li>
                <li>Planning the Development Process
                    <ol>
                        <li>The Phased Life-Cycle Model</li>
                        <li>Milestones, Documents, and Reviews</li>
                        <li>The Cost Model</li>
                        <li>The Prototype Life-Cycle Model</li>
                        <li>Successive Versions</li>
                    </ol>
                </li>
                <li>Planning an Organizational Structure
                    <ol>
                        <li>Project Structure</li>
                        <li>Programming Team Structure</li>
                        <li>Management By Objectives</li>
                    </ol>
                </li>
                <li>Other Planning Activities
                    <ol>
                        <li>Planning for Configuration Management and Quality Assurance</li>
                        <li>Planning for Independent Verification and Validation</li>
                        <li>Planning Phase-Dependent Tools and Techniques</li>
                        <li>Other Planning Activities</li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>
            Software Cost Estimation
            <ol>
                <li>Introduction</li>
                <li>Software Cost Factors
                    <ol>
                        <li>Programmer Ability</li>
                        <li>Product Complexity</li>
                        <li>Product Size</li>
                        <li>Available Time</li>
                        <li>Required Level of Reliability</li>
                        <li>Level of Technology</li>
                    </ol>
                </li>
                <li>
                    Software Cost Estimation Techniques
                    <ol>
                        <li>Expert Judgement</li>
                        <li>Delphi Cost Estimation</li>
                        <li>Work Breakdown Structures</li>
                        <li>Algorithmic Cost Models</li>
                    </ol>
                </li>
                <li>Staffing-Level Estimation</li>
                <li>Estimating Software Maintenance Costs</li>
            </ol>
        </li>
        <li>
            Software Requirements Definitions
            <ol>
                <li>Introduction</li>
                <li>The <em>Software Requirements Specification</em></li>
                <li>Formal Specification Techniques
                    <ol>
                        <li>Relational Notations (Implicit Equations/Recurrence Relations/Algebraic Axioms/Regular Expressions)</li>
                        <li>State-Oriented Notations (Decision Tables/Event Tables/Transition Tables/Finite-State Mechanisms/Petri Nets)</li>
                    </ol>
                </li>
                <li>Languages and Processors for Requirements Specification
                    <ol>
                        <li>PSL/PSA</li>
                        <li>RSL/REVS</li>
                        <li>Structured Analysis and Design Technique (SADT)</li>
                        <li>Structured System Analysis (SSA)</li>
                        <li>GIST</li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>
            Software Design
            <ol>
                <li>Introduction</li>
                <li>Fundamental Design Concepts
                    <ol>
                        <li>Abstraction</li>
                        <li>Information Hiding</li>
                        <li>Structure</li>
                        <li>Modularity</li>
                        <li>Concurrency</li>
                        <li>Verification</li>
                        <li>Aesthetics</li>
                    </ol>
                </li>
                <li>
                    Modules and Modularization Criteria
                    <ol>
                        <li>Coupling and Cohesion</li>
                        <li>Other Modularization Criteria</li>
                    </ol>
                </li>
                <li>
                    Design Notations
                    <ol>
                        <li>Data Flow Diagrams</li>
                        <li>Structure Charts</li>
                        <li>HIPO Diagrams</li>
                        <li>Procedure Templates</li>
                        <li>Pseudocode</li>
                        <li>Structured Flowcharts</li>
                        <li>Structured English</li>
                        <li>Decision Tables</li>
                    </ol>
                </li>
                <li>Design Techniques
                    <ol>
                        <li>Stepwise Refinement</li>
                        <li>Levels of Abstraction</li>
                        <li>Structured Design</li>
                        <li>Integrated Top-Down Development</li>
                        <li>Jackson Structured Programming</li>
                    </ol>
                </li>
                <li>Detailed Design Considerations</li>
                <li>Real-Time and Distributed System Design</li>
                <li>Test Plans</li>
                <li>Milestones, Walkthroughs, and Inspections</li>
                <li>Design Guidelines</li>
            </ol>
        </li>
        <li>Implementation Issues
            <ol>
                <li>Structured Coding Techniques
                    <ol>
                        <li>Single Entry, Single Exit Constructs</li>
                        <li>Efficiency Considerations</li>
                        <li>Violations of Single Entry, Single Exit</li>
                        <li>Data Encapsulation</li>
                        <li>The Goto Statement</li>
                        <li>Recursion</li>
                    </ol>
                </li>
                <li>Coding Style</li>
                <li>Standards and Guidelines</li>
                <li>Documentation Guidelines
                    <ol>
                        <li>Supporting Documents</li>
                        <li>Program Unit Notebooks</li>
                        <li>Internal Documentation</li>
                    </ol>
                </li>
            </ol>
        </li>
        <li>Modern Programming Language Features
            <ol>
                <li>Introduction</li>
                <li>Type Checking</li>
                <li>Separate Compilation</li>
                <li>User-Defined Data Types</li>
                <li>Data Abstraction</li>
                <li>Scoping Rules</li>
                <li>Exception Handling</li>
                <li>Concurrency Mechanisms</li>
            </ol>
        </li>
        <li>Software Maintenance
            <ol>
                <li>Introduction</li>
                <li>Enhancing Maintainability during Development</li>
                <li>Managerial Aspects of Software Maintenance</li>
                <li>Configuration Management</li>
                <li>Source-Code Metrics</li>
                <li>Other Maintenance Tools and Techniques</li>
            </ol>
        </li>
    </ol>
</details>

<details>
    <summary>Notes</summary>
    <p><strong>5.7 Test Plans</strong></p>
<p>
  A test plan prescribed various kinds of activities that will be performed to
  demonstrate that the software product meets its requirements.
</p>
<p>
  There are four types of tests that a software product must satisfy: functional
  tests, performance tests, stress tests, and structural tests. Functional tests
  and performance tests are based on the requirements specifications; they are
  designed to demonstrate that the system satisfies its requirements. Therefore,
  the test plan can be only as good as the requirements, which in turn must be
  phrased in quantified, testable terms.
</p>
<p>
  Functional test cases specify typical operating conditions, typical input
  values, and typical expected results.
</p>
<p>
  Performance tests should be designed to verify response time (under various
  loads), execution time, throughput, primary and secondary memory utilization,
  and traffic rates on data channels and communication links. Performance tests
  will often indicate processing bottlenecks to be addressed during system
  testing and tuning.
</p>
<p>
  It is particularly important that the expected results of each test be
  specified prior to system implementation and actual testing.
</p>
<p>
  Stress tests are designed to overload a system in various ways. The purposes
  of stress testing are to determine the limitations of the system and, when the
  system fails, to determine the manner in which the failure is manifest.
</p>
<p>
  Structural tests are concerned with examining the internal processing logic of
  a software system. The goal of structural testing is to traverse a specified
  number of paths through each routine in the system to establish thoroughness
  of testing.
</p>
<p><strong>5.8 Milestones, walkthroughs, and inspections</strong></p>
<p>
  The two major milestones during software design are the Preliminary Design
  Review (PDR) and the Critical Design Review (CDR).
</p>
<p>
  The major goal of PDR is to demonstrate that the externally observable
  characteristics and architectural structure of the product will satisfy the
  customer&rsquo;s requirements. Functional characteristics, performance
  attributes, external interfaces, user dialogues, report formats, exception
  conditions and exception handling, product subsets, and future enhancements to
  the product should all be reviewed during the PDR.
</p>
<h3>Chapter Six: Implementation issues</h3>
<p><strong>Introduction</strong></p>
<p>
  The primary goal of implementation is to write source code and internal
  documentation so that conformance of the code to its specifications can be
  easily verified, and so that debugging, testing, and modification are eased.
</p>
<p><strong>6.1 Structured coding techniques</strong></p>
<p>
  The goal of structured coding is to linearize control flow through a computer
  program so that the execution sequence follows the sequence in which the code
  is written.
</p>
<p><strong>6.1.1 Single entry, single exit constructs</strong></p>
<p>
  A modified version of the Bohm-Jacopini theorem can be stated as follows:
  <em
    >Any single entry, single exit program segment that has all statements on
    some path from the entry to the exit can be specified using only sequencing,
    selection, and iteration.</em
  >
</p>
<p>
  A sufficient set of single entry; single exit constructs for specifying
  control flow in algorithms is:
</p>
<ul>
  <li>Sequencing: S1; S2; S3;</li>
  <li>Selection: if B then S1 else S2;</li>
  <li>Iteration: while B do S;</li>
</ul>
<p><strong>6.4.3 Internal documentation</strong></p>
<p>Table 6.3: Typical format of subprogram and compilation unit prologues</p>
<p>Name of author:</p>
<p>Date of compilation:</p>
<p>Function(s) performed:</p>
<p>Algorithms used:</p>
<p>Author/date/purpose of modifications:</p>
<p>Parameters and modes:</p>
<p>Input assertion:</p>
<p>Output assertion:</p>
<p>Global variables:</p>
<p>Side effects:</p>
<p>Major data structures:</p>
<p>Calling routines:</p>
<p>Called routines:</p>
<p>Timing constraints:</p>
<p>Exception handling:</p>
<p>Assumptions:</p>
<p>Table 6.4 Commenting conventions</p>
<ol>
  <li>Minimize the need for embedded comments by using:</li>
  <ol>
    <li>Standard prologues</li>
    <li>Structured programming constructs</li>
    <li>Good coding style</li>
    <li>
      Descriptive names from the problem domain for user-defined data types,
      variables, formal parameters, enumeration literals, subprograms, files,
      etc.
    </li>
    <li>
      Self-documenting features of the implementation language, such as
      user-defined exceptions, user-defined data types, data encapsulation, etc.
    </li>
  </ol>
  <li>Attach comments to code that:</li>
  <ol>
    <li>Perform major data manipulations</li>
    <li>Simulate structured control constructs using goto statements</li>
  </ol>
  <li>Use problem domain terminology in the comments.</li>
  <li>Use blank lines, borders, and indentation to highlight comments.</li>
  <li>Place comments to the far right to document changes and revisions.</li>
  <li>
    Don&rsquo;t use long, involved comments to document obscure, complex code.
    Rewrite the code.
  </li>
  <li>
    Always be sure that comments and code agree with one another, and with the
    requirements and design specifications.
  </li>
</ol>
<p><strong>8.1 Quality Assurance</strong></p>
<p>
  Quality assurance is &ldquo;a planned and systematic pattern of all actions
  necessary to provide adequate confidence that the item or product conforms to
  established technical requirements.&rdquo; (IEE83)
</p>
<p>Topics in a Software Quality Assurance Plan include (BUC79):</p>
<ol>
  <li>Purpose and scope of the plan</li>
  <li>Documents referenced in the plan</li>
  <li>
    Organizational structure, tasks to be performed, and specific
    responsibilities as they relate to product quality
  </li>
  <li>
    Documents to be prepared and checks to be made for adequacy of the
    documentation
  </li>
  <li>Standards, practices, and conventions to be used</li>
  <li>Reviews and audits to be conducted</li>
  <li>
    A configuration management plan that identifies software product items,
    controls and implements changes, and records and reports changed status
  </li>
  <li>
    Practices and procedures to be following reporting, tracking, and resolving
    software problems
  </li>
  <li>
    Specific tools and techniques to be used to support quality assurance
    activities
  </li>
  <li>
    Methods and facilities to be used to maintain and store controlled versions
    of identified software
  </li>
  <li>
    Methods and facilities to be used to protect computer program physical media
  </li>
  <li>
    Provisions for ensuring the quality of vendor-provided and
    subcontractor-developed software
  </li>
  <li>
    Methods and facilities to be used in collecting, maintaining, and retaining
    quality assurance records
  </li>
</ol>
<p><strong>9.1 Enhancing maintainability during development</strong></p>
<p>Table 9.1 Development activities that enhance software maintainability</p>
<ul>
  <li>Analysis activities</li>
  <ul>
    <li>Develop standards and guidelines</li>
    <li>Set milestones for the supporting documents</li>
    <li>Specify quality assurance procedures</li>
    <li>identify likely product enhancements</li>
    <li>Determine resources required for maintenance</li>
    <li>Estimate maintenance costs</li>
  </ul>
  <li>Architectural Design Activities</li>
  <ul>
    <li>Emphasize clarity and modularity as design criteria</li>
    <li>Design to ease likely enhancements</li>
    <li>
      Use standardized notations to document data flow, functions, structure,
      and interconnections
    </li>
    <li>
      Observe the principles of information hiding, data abstraction, and
      top-down hierarchical decomposition
    </li>
  </ul>
  <li>Detailed Design Activities</li>
  <ul>
    <li>
      Use standardized notations to specify algorithms, data structures, and
      procedure interface specifications
    </li>
    <li>Specify side effects and exception handling for each routine</li>
    <li>Provide cross-reference directories</li>
  </ul>
  <li>Implementation Activities</li>
  <ul>
    <li>Use single entry, single exit constructs</li>
    <li>Use standard indentation of constructs</li>
    <li>Use simple, clear coding style</li>
    <li>Use symbolic constants to parameter use routines</li>
    <li>Provide margins on resources</li>
    <li>Provide standard documentation prologues for each routine</li>
    <li>Follow standard internal commenting guidelines</li>
  </ul>
  <li>Other activities</li>
  <ul>
    <li>Develop a maintenance guide</li>
    <li>Develop a test suite</li>
    <li>Provide test suite documentation</li>
  </ul>
</ul>
<p>9.2 Managerial aspects of software maintenance</p>
<p>Change request processing can be described by the following algorithm:</p>
<p>&mdash;-</p>
<p>Project Legacy</p>
<ol>
  <li>Project Description</li>
  <li>Initial expectations</li>
  <li>Current status of the project</li>
  <li>Remaining areas of concern</li>
  <li>Activities/time logs</li>
  <li>Technical lessons learned</li>
  <li>Managerial lessons learned</li>
  <li>Recommendations to future projects</li>
</ol>
</details>
